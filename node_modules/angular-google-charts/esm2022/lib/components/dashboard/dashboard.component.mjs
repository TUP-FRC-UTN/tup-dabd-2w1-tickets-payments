import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { combineLatest } from 'rxjs';
import { DataTableService } from '../../services/data-table.service';
import { ScriptLoaderService } from '../../services/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
import * as i0 from "@angular/core";
import * as i1 from "../../services/script-loader.service";
import * as i2 from "../../services/data-table.service";
export class DashboardComponent {
    constructor(element, loaderService, dataTableService) {
        this.element = element;
        this.loaderService = loaderService;
        this.dataTableService = dataTableService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns || changes.formatters) {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.registerEvents();
            this.dashboard.draw(this.dataTable);
        });
    }
    registerEvents() {
        google.visualization.events.removeAllListeners(this.dashboard);
        const registerDashEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerDashEvent(this.dashboard, 'ready', () => this.ready.emit());
        registerDashEvent(this.dashboard, 'error', (error) => this.error.emit(error));
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DashboardComponent, deps: [{ token: i0.ElementRef }, { token: i1.ScriptLoaderService }, { token: i2.DataTableService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DashboardComponent, selector: "dashboard", inputs: { data: "data", columns: "columns", formatters: "formatters" }, outputs: { ready: "ready", error: "error" }, host: { classAttribute: "dashboard" }, queries: [{ propertyName: "controlWrappers", predicate: ControlWrapperComponent }], exportAs: ["dashboard"], usesOnChanges: true, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DashboardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'dashboard',
                    template: '<ng-content></ng-content>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'dashboard',
                    host: { class: 'dashboard' }
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.ScriptLoaderService }, { type: i2.DataTableService }]; }, propDecorators: { data: [{
                type: Input
            }], columns: [{
                type: Input
            }], formatters: [{
                type: Input
            }], ready: [{
                type: Output
            }], error: [{
                type: Output
            }], controlWrappers: [{
                type: ContentChildren,
                args: [ControlWrapperComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZ29vZ2xlLWNoYXJ0cy9zcmMvbGliL2NvbXBvbmVudHMvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUdMLE1BQU0sRUFDTixTQUFTLEVBRVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVyQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUNyRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUkzRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQzs7OztBQVN2RixNQUFNLE9BQU8sa0JBQWtCO0lBbUQ3QixZQUNVLE9BQW1CLEVBQ25CLGFBQWtDLEVBQ2xDLGdCQUFrQztRQUZsQyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLGtCQUFhLEdBQWIsYUFBYSxDQUFxQjtRQUNsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBM0I1Qzs7Ozs7O1dBTUc7UUFFSSxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUV4Qzs7O1dBR0c7UUFFSSxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7UUFPM0MsZ0JBQVcsR0FBRyxLQUFLLENBQUM7SUFNekIsQ0FBQztJQUVHLFFBQVE7UUFDYixJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDOUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMs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ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhVGFibGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZGF0YS10YWJsZS5zZXJ2aWNlJztcbmltcG9ydCB7IFNjcmlwdExvYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zY3JpcHQtbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2hhcnRFcnJvckV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gJy4uLy4uL3R5cGVzL2Zvcm1hdHRlcic7XG5pbXBvcnQgeyBDb2x1bW4sIFJvdyB9IGZyb20gJy4uL2NoYXJ0LWJhc2UvY2hhcnQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udHJvbFdyYXBwZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb250cm9sLXdyYXBwZXIvY29udHJvbC13cmFwcGVyLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Rhc2hib2FyZCcsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ2Rhc2hib2FyZCcsXG4gIGhvc3Q6IHsgY2xhc3M6ICdkYXNoYm9hcmQnIH1cbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICAvKipcbiAgICogRGF0YSB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHRhYmxlLlxuICAgKlxuICAgKiBUaGlzIG11c3QgYWxzbyBjb250YWluIGFsbCByb2xlcyB0aGF0IGFyZSBzZXQgaW4gdGhlIGBjb2x1bW5zYCBwcm9wZXJ0eS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBkYXRhITogUm93W107XG5cbiAgLyoqXG4gICAqIFRoZSBjb2x1bW5zIHRoZSBgZGF0YWAgY29uc2lzdHMgb2YuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2YgZWFjaCByb3cgaW4gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAqXG4gICAqIElmIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jaGFydC9pbnRlcmFjdGl2ZS9kb2NzL3JvbGVzIHJvbGVzfSBzaG91bGQgYmUgYXBwbGllZCwgdGhleSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoaXMgYXJyYXkgYXMgd2VsbC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBjb2x1bW5zPzogQ29sdW1uW107XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2hhbmdlIHRoZSBkaXNwbGF5ZWQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4gaW4gYWxsIHJvd3MuXG4gICAqXG4gICAqIEVhY2ggYXJyYXkgZWxlbWVudCBtdXN0IGNvbnNpc3Qgb2YgYW4gaW5zdGFuY2Ugb2YgYSBbYGZvcm1hdHRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3MvcmVmZXJlbmNlI2Zvcm1hdHRlcnMpXG4gICAqIGFuZCB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB5b3Ugd2FudCB0aGUgZm9ybWF0dGVyIHRvIGdldCBhcHBsaWVkIHRvLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGZvcm1hdHRlcnM/OiBGb3JtYXR0ZXJbXTtcblxuICAvKipcbiAgICogVGhlIGRhc2hib2FyZCBoYXMgY29tcGxldGVkIGRyYXdpbmcgYW5kIGlzIHJlYWR5IHRvIGFjY2VwdCBjaGFuZ2VzLlxuICAgKlxuICAgKiBUaGUgcmVhZHkgZXZlbnQgd2lsbCBhbHNvIGZpcmU6XG4gICAqIC0gYWZ0ZXIgdGhlIGNvbXBsZXRpb24gb2YgYSBkYXNoYm9hcmQgcmVmcmVzaCB0cmlnZ2VyZWQgYnkgYSB1c2VyIG9yIHByb2dyYW1tYXRpYyBpbnRlcmFjdGlvbiB3aXRoIG9uZSBvZiB0aGUgY29udHJvbHMsXG4gICAqIC0gYWZ0ZXIgcmVkcmF3aW5nIGFueSBjaGFydCBvbiB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyByZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hlbiBhdHRlbXB0aW5nIHRvIHJlbmRlciB0aGUgZGFzaGJvYXJkLlxuICAgKiBPbmUgb3IgbW9yZSBvZiB0aGUgY29udHJvbHMgYW5kIGNoYXJ0cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBkYXNoYm9hcmQgbWF5IGhhdmUgZmFpbGVkIHJlbmRlcmluZy5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBwdWJsaWMgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0RXJyb3JFdmVudD4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKENvbnRyb2xXcmFwcGVyQ29tcG9uZW50KVxuICBwcml2YXRlIGNvbnRyb2xXcmFwcGVycyE6IFF1ZXJ5TGlzdDxDb250cm9sV3JhcHBlckNvbXBvbmVudD47XG5cbiAgcHJpdmF0ZSBkYXNoYm9hcmQ/OiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQ7XG4gIHByaXZhdGUgZGF0YVRhYmxlPzogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlO1xuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgbG9hZGVyU2VydmljZTogU2NyaXB0TG9hZGVyU2VydmljZSxcbiAgICBwcml2YXRlIGRhdGFUYWJsZVNlcnZpY2U6IERhdGFUYWJsZVNlcnZpY2VcbiAgKSB7fVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmxvYWRlclNlcnZpY2UubG9hZENoYXJ0UGFja2FnZXMoJ2NvbnRyb2xzJykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuZGF0YVRhYmxlID0gdGhpcy5kYXRhVGFibGVTZXJ2aWNlLmNyZWF0ZSh0aGlzLmRhdGEsIHRoaXMuY29sdW1ucywgdGhpcy5mb3JtYXR0ZXJzKTtcbiAgICAgIHRoaXMuY3JlYXRlRGFzaGJvYXJkKCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuZGF0YSB8fCBjaGFuZ2VzLmNvbHVtbnMgfHwgY2hhbmdlcy5mb3JtYXR0ZXJzKSB7XG4gICAgICB0aGlzLmRhdGFUYWJsZSA9IHRoaXMuZGF0YVRhYmxlU2VydmljZS5jcmVhdGUodGhpcy5kYXRhLCB0aGlzLmNvbHVtbnMsIHRoaXMuZm9ybWF0dGVycyk7XG4gICAgICB0aGlzLmRhc2hib2FyZCEuZHJhdyh0aGlzLmRhdGFUYWJsZSEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGFzaGJvYXJkKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGhhcHBlbiBpbiB0aGUgY29udHJvbCB3cmFwcGVyXG4gICAgLy8gSG93ZXZlciwgSSBkb24ndCB5ZXQga25vdyBob3cgdG8gZG8gdGhpcyBiZWNhdXNlIHRoZW4gYGJpbmQoKWAgd291bGQgZ2V0IGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIGZvciB0aGUgc2FtZSBjb250cm9sIGlmIHNvbWV0aGluZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZ29vZ2xlIGNoYXJ0cyBhcyBmYXIgYXMgSSBjYW4gdGVsbFxuICAgIC8vIGZyb20gdGhlaXIgc291cmNlIGNvZGUuXG4gICAgY29uc3QgY29udHJvbFdyYXBwZXJzUmVhZHkkID0gdGhpcy5jb250cm9sV3JhcHBlcnMubWFwKGNvbnRyb2wgPT4gY29udHJvbC53cmFwcGVyUmVhZHkkKTtcbiAgICBjb25zdCBjaGFydHNSZWFkeSQgPSB0aGlzLmNvbnRyb2xXcmFwcGVyc1xuICAgICAgLm1hcChjb250cm9sID0+IGNvbnRyb2wuZm9yKVxuICAgICAgLm1hcChjaGFydHMgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFydHMpKSB7XG4gICAgICAgICAgLy8gQ29tYmluZUxhdGVzdCB3YWl0cyBmb3IgYWxsIG9ic2VydmFibGVzXG4gICAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoY2hhcnRzLm1hcChjaGFydCA9PiBjaGFydC53cmFwcGVyUmVhZHkkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0cy53cmFwcGVyUmVhZHkkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIFdlIGhhdmUgdG8gd2FpdCBmb3IgYWxsIGNoYXJ0IHdyYXBwZXJzIGFuZCBjb250cm9sIHdyYXBwZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgLy8gYmVmb3JlIHdlIGNhbiBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gY3JlYXRlIHRoZSBkYXNoYm9hcmRcbiAgICBjb21iaW5lTGF0ZXN0KFsuLi5jb250cm9sV3JhcHBlcnNSZWFkeSQsIC4uLmNoYXJ0c1JlYWR5JF0pLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmRhc2hib2FyZCA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgdGhpcy5pbml0aWFsaXplQmluZGluZ3MoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkLmRyYXcodGhpcy5kYXRhVGFibGUhKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJFdmVudHMoKTogdm9pZCB7XG4gICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmRhc2hib2FyZCk7XG5cbiAgICBjb25zdCByZWdpc3RlckRhc2hFdmVudCA9IChvYmplY3Q6IGFueSwgZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikgPT4ge1xuICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKG9iamVjdCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHJlZ2lzdGVyRGFzaEV2ZW50KHRoaXMuZGFzaGJvYXJkLCAncmVhZHknLCAoKSA9PiB0aGlzLnJlYWR5LmVtaXQoKSk7XG4gICAgcmVnaXN0ZXJEYXNoRXZlbnQodGhpcy5kYXNoYm9hcmQsICdlcnJvcicsIChlcnJvcjogQ2hhcnRFcnJvckV2ZW50KSA9PiB0aGlzLmVycm9yLmVtaXQoZXJyb3IpKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUJpbmRpbmdzKCk6IHZvaWQge1xuICAgIHRoaXMuY29udHJvbFdyYXBwZXJzLmZvckVhY2goY29udHJvbCA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sLmZvcikpIHtcbiAgICAgICAgY29uc3QgY2hhcnRXcmFwcGVycyA9IGNvbnRyb2wuZm9yLm1hcChjaGFydCA9PiBjaGFydC5jaGFydFdyYXBwZXIpO1xuICAgICAgICB0aGlzLmRhc2hib2FyZCEuYmluZChjb250cm9sLmNvbnRyb2xXcmFwcGVyLCBjaGFydFdyYXBwZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkIS5iaW5kKGNvbnRyb2wuY29udHJvbFdyYXBwZXIsIGNvbnRyb2wuZm9yLmNoYXJ0V3JhcHBlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==